[1mdiff --git a/core/src/parser/mod.rs b/core/src/parser/mod.rs[m
[1mindex 979c806..2c6b0a6 100644[m
[1m--- a/core/src/parser/mod.rs[m
[1m+++ b/core/src/parser/mod.rs[m
[36m@@ -95,7 +95,7 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
         cur[m
     }[m
 [m
[31m-    fn is_index_assign(&self) -> bool {[m
[32m+[m[32m    fn is_index_assign(&self) -> AssignmentType {[m
         let mut i = self.index() + 2;[m
         let mut open_bracket_count = 1;[m
 [m
[36m@@ -103,13 +103,18 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
             match self.tokens[i].kind {[m
                 TokenKind::OpenBracket => open_bracket_count += 1,[m
                 TokenKind::CloseBracket if open_bracket_count == 1 => {[m
[32m+[m[32m                    if self.tokens[i + 1].is_calc_assign()[m
[32m+[m[32m                        && self.tokens[i + 2].kind == TokenKind::AssignmentOperator[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return AssignmentType::CalcAssignment;[m
[32m+[m[32m                    }[m
                     match self.tokens[i + 1].kind {[m
                         // Add an extra so that the OpenBracket is skipped, and do not change[m
                         // open_bracket_count since it needs to be decremented for the CloseBracket[m
                         // and incremented for the OpenBracket[m
                         TokenKind::OpenBracket => i += 1,[m
[31m-                        TokenKind::AssignmentOperator => return true,[m
[31m-                        _ => return false,[m
[32m+[m[32m                        TokenKind::AssignmentOperator => return AssignmentType::Assignment,[m
[32m+[m[32m                        _ => return AssignmentType::None,[m
                     }[m
                 }[m
                 TokenKind::CloseBracket => open_bracket_count -= 1,[m
[36m@@ -119,7 +124,7 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
             i += 1;[m
         }[m
 [m
[31m-        false[m
[32m+[m[32m        AssignmentType::None[m
     }[m
 [m
     // ----- Parse Methods -----[m
[36m@@ -155,9 +160,16 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
                 self.parse_assignment_expression()[m
             }[m
             TokenKind::Ident[m
[31m-                if self.peek(1).kind == TokenKind::OpenBracket && self.is_index_assign() =>[m
[32m+[m[32m                if self.peek(1).kind == TokenKind::OpenBracket[m
[32m+[m[32m                    && self.is_index_assign() == AssignmentType::Assignment =>[m
[32m+[m[32m            {[m
[32m+[m[32m                self.parse_assignment_expression()[m
[32m+[m[32m            }[m
[32m+[m[32m            TokenKind::Ident[m
[32m+[m[32m                if self.peek(1).kind == TokenKind::OpenBracket[m
[32m+[m[32m                    && self.is_index_assign() == AssignmentType::CalcAssignment =>[m
             {[m
[31m-                self.parse_index_assignment_expression()[m
[32m+[m[32m                self.parse_calc_assignment_expression()[m
             }[m
             TokenKind::Ident[m
                 if self.peek(1).is_calc_assign()[m
[36m@@ -191,32 +203,52 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
 [m
     fn parse_assignment_expression(&self) -> SyntaxNode {[m
         let ident = self.next();[m
[31m-        self.next();[m
[31m-        let value = self.parse_statement();[m
[31m-        SyntaxNode::AssignmentNode(node::AssignmentNode::new(ident, value, self.src))[m
[31m-    }[m
 [m
[31m-    fn parse_index_assignment_expression(&self) -> SyntaxNode {[m
[31m-        let ident = self.next();[m
[31m-        let mut indices = vec![];[m
[31m-        while self.cur().kind == TokenKind::OpenBracket {[m
[31m-            self.next();[m
[31m-            indices.push(self.parse_statement());[m
[31m-            self.match_token(TokenKind::CloseBracket);[m
[31m-        }[m
[32m+[m[32m        let indices = if self.cur().kind == TokenKind::OpenBracket {[m
[32m+[m[32m            let mut indices = Vec::new();[m
[32m+[m[32m            while self.cur().kind == TokenKind::OpenBracket {[m
[32m+[m[32m                self.next();[m
[32m+[m[32m                indices.push(self.parse_statement());[m
[32m+[m[32m                self.match_token(TokenKind::CloseBracket);[m
[32m+[m[32m            }[m
[32m+[m[32m            Some(indices)[m
[32m+[m[32m        } else {[m
[32m+[m[32m            None[m
[32m+[m[32m        };[m
[32m+[m
         self.next();[m
         let value = self.parse_statement();[m
[31m-        SyntaxNode::AssignmentNode(node::AssignmentNode::new_index([m
[31m-            ident, indices, value, self.src,[m
[31m-        ))[m
[32m+[m[32m        SyntaxNode::AssignmentNode(node::AssignmentNode::new(ident, indices, value, self.src))[m
     }[m
 [m
     fn parse_calc_assignment_expression(&self) -> SyntaxNode {[m
         let ident = self.next();[m
[32m+[m
[32m+[m[32m        let indices = if self.cur().kind == TokenKind::OpenBracket {[m
[32m+[m[32m            let mut indices = Vec::new();[m
[32m+[m[32m            while self.cur().kind == TokenKind::OpenBracket {[m
[32m+[m[32m                self.next();[m
[32m+[m[32m                indices.push(self.parse_statement());[m
[32m+[m[32m                self.match_token(TokenKind::CloseBracket);[m
[32m+[m[32m            }[m
[32m+[m[32m            Some(indices)[m
[32m+[m[32m        } else {[m
[32m+[m[32m            None[m
[32m+[m[32m        };[m
[32m+[m
         let op = self.next();[m
         let span = TextSpan::from_spans(&op.text_span, &self.next().text_span);[m
 [m
[31m-        let left = SyntaxNode::VariableNode(node::VariableNode::new(ident, self.src));[m
[32m+[m[32m        let mut left = SyntaxNode::VariableNode(node::VariableNode::new(ident, self.src));[m
[32m+[m[32m        if let Some(ref indices) = indices {[m
[32m+[m[32m            for index in indices {[m
[32m+[m[32m                left = SyntaxNode::IndexNode(node::IndexNode::from_span([m
[32m+[m[32m                    left,[m
[32m+[m[32m                    index.clone(),[m
[32m+[m[32m                    index.span().clone(),[m
[32m+[m[32m                ))[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
         let right = self.parse_statement();[m
 [m
         let value = SyntaxNode::BinaryNode(node::BinaryNode::with_span([m
[36m@@ -226,7 +258,7 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
             span,[m
         ));[m
 [m
[31m-        SyntaxNode::AssignmentNode(node::AssignmentNode::new(ident, value, self.src))[m
[32m+[m[32m        SyntaxNode::AssignmentNode(node::AssignmentNode::new(ident, indices, value, self.src))[m
     }[m
 [m
     fn parse_fn_declaration_statement(&self) -> SyntaxNode {[m
[36m@@ -496,3 +528,11 @@[m [mimpl<'diagnostics, 'src> Parser<'diagnostics, 'src> {[m
         }[m
     }[m
 }[m
[32m+[m
[32m+[m[32m#[derive(PartialEq, Eq)][m
[32m+[m[32m#[repr(u8)][m
[32m+[m[32menum AssignmentType {[m
[32m+[m[32m    Assignment,[m
[32m+[m[32m    CalcAssignment,[m
[32m+[m[32m    None,[m
[32m+[m[32m}[m
[1mdiff --git a/core/src/syntax_node/assignment_node.rs b/core/src/syntax_node/assignment_node.rs[m
[1mindex 7cbf8ad..8df1b53 100644[m
[1m--- a/core/src/syntax_node/assignment_node.rs[m
[1m+++ b/core/src/syntax_node/assignment_node.rs[m
[36m@@ -15,25 +15,16 @@[m [mpub struct AssignmentNode {[m
 }[m
 [m
 impl AssignmentNode {[m
[31m-    pub fn new(ident_token: &Token, value: SyntaxNode, src: &SourceText) -> Self {[m
[31m-        Self {[m
[31m-            ident: src[&ident_token.text_span].to_owned(),[m
[31m-            span: TextSpan::from_spans(&ident_token.text_span, value.span()),[m
[31m-            indices: None,[m
[31m-            value: Box::new(value),[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    pub fn new_index([m
[32m+[m[32m    pub fn new([m
         ident_token: &Token,[m
[31m-        indices: Vec<SyntaxNode>,[m
[32m+[m[32m        indices: Option<Vec<SyntaxNode>>,[m
         value: SyntaxNode,[m
         src: &SourceText,[m
     ) -> Self {[m
         Self {[m
             ident: src[&ident_token.text_span].to_owned(),[m
             span: TextSpan::from_spans(&ident_token.text_span, value.span()),[m
[31m-            indices: Some(indices),[m
[32m+[m[32m            indices: indices,[m
             value: Box::new(value),[m
         }[m
     }[m
[1mdiff --git a/core/tests/lists.rs b/core/tests/lists.rs[m
[1mindex 83f626c..23ea4e6 100644[m
[1m--- a/core/tests/lists.rs[m
[1m+++ b/core/tests/lists.rs[m
[36m@@ -56,12 +56,13 @@[m [mfn nested_index() {[m
     assert_eq!([m
         execute([m
             "let l = [123, [123.1, [9812]]][m
[32m+[m[32m            l[0] += 50[m
             l[1][0] = 50[m
             l[-1][1][-1] = 'hello world'"[m
         )[m
         .unwrap(),[m
         v::l(vec![[m
[31m-            v::i(123),[m
[32m+[m[32m            v::i(173),[m
             v::l(vec![v::i(50), v::l(vec![v::s("hello world")])]),[m
         ]),[m
     );[m
